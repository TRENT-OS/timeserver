/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(DATA61_BSD)
 */

/*
 *  TimeServer
 *
 *  Copyright (C) 2020, Hensoldt Cyber GmbH
 */

#include <autoconf.h>

#include <assert.h>
#include <stdio.h>
#include <stdbool.h>
#include <stdio.h>
#include <errno.h>
#include <sel4/sel4.h>
#include <sel4/arch/constants.h>
#include <camkes.h>
#include <camkes/irq.h>
#include <platsupport/time_manager.h>
#include <platsupport/local_time_manager.h>
#include <platsupport/irq.h>
#include <utils/util.h>
#include <sel4utils/sel4_zf_logif.h>
#include <simple/simple.h>
#include <camkes/io.h>

#include "OS_Error.h"
#include "LibDebug/Debug.h"

#include "plat.h"

// Get a client when called via RPC
#define GET_CLIENT(cli, cid) \
    do { \
        if ((cli = getClient(cid)) == NULL) \
        { \
            Debug_LOG_ERROR("Could not get state for client with client ID %u, " \
                            "the badge number is most likely not properly " \
                            "configured", cid); \
            return OS_ERROR_NOT_FOUND; \
        } \
    } while(0)

/* ltimer for accessing timer devices */
static ltimer_t ltimer;
/* time manager for timeout multiplexing */
static time_manager_t timeManager;

typedef struct
{
    unsigned int cid;
    uint32_t timers;
    void (*notify)(void);
} TimeServer_Client;

// Maximum amount of clients allowed
#define TIMESERVER_CLIENTS_MAX 8
// Assign the clients
static TimeServer_Client timerClients[TIMESERVER_CLIENTS_MAX] =
{
    { 101, 0, timeServer_notify1_emit },
    { 102, 0, timeServer_notify2_emit },
    { 103, 0, timeServer_notify3_emit },
    { 104, 0, timeServer_notify4_emit },
    { 105, 0, timeServer_notify5_emit },
    { 106, 0, timeServer_notify6_emit },
    { 107, 0, timeServer_notify7_emit },
};

// Translate between badge IDs and array index
#define CID_TO_IDX(cid) ((cid)-101)
#define IDX_TO_CID(idx) ((idx)+101)

/* Prototype for this function is not generated by the camkes templates yet */
seL4_Word timeServer_rpc_get_sender_id();

static ps_io_ops_t io_ops;

// Private Functions -----------------------------------------------------------

static inline uint64_t
currentTimeNs(
    void)
{
    uint64_t time;

    int error = ltimer_get_time(&ltimer, &time);
    ZF_LOGF_IF(error, "Failed to get time");

    return time;
}

static TimeServer_Client*
getClient(
    seL4_Word cid)
{
    const int idx = CID_TO_IDX(cid);
    TimeServer_Client* client;

    client = ((idx < 0) || (idx >= TIMESERVER_CLIENTS_MAX))
             ? NULL : (timerClients[idx].cid != cid)
             ? NULL : &timerClients[idx];

    return client;
}

static inline unsigned int
getTimeToken(
    TimeServer_Client* client,
    int                tid)
{
    return (unsigned int) CID_TO_IDX(client->cid) * timers_per_client + tid;
}

static int
signalClient(
    uintptr_t token)
{
    TimeServer_Client* client;

    int idx = ((int) token) / timers_per_client;
    int tid = ((int) token) % timers_per_client;

    client = &timerClients[idx];
    client->timers |= BIT(tid);
    client->notify();

    return 0;
}

static void
timerHandler(
    UNUSED void*   emptyToken,
    ltimer_event_t lTimerEvent)
{
    int error = clientMux_lock();
    ZF_LOGF_IF(error, "Failed to lock time server");

    error = tm_update(&timeManager);
    ZF_LOGF_IF(error, "Failed to update time manager");

    error = clientMux_unlock();
    ZF_LOGF_IF(error, "Failed to unlock time server");
}

static OS_Error_t
_oneshot_relative(
    TimeServer_Client* client,
    int                tid,
    uint64_t           ns)
{
    if (tid >= timers_per_client || tid < 0)
    {
        ZF_LOGE("invalid tid, 0 >= %d >= %d\n", tid, timers_per_client);
        return OS_ERROR_INVALID_PARAMETER;
    }

    int error = clientMux_lock();
    ZF_LOGF_IF(error, "Failed to lock time server");

    unsigned int id = getTimeToken(client, tid);

    error = tm_register_rel_cb(&timeManager, ns, id, signalClient,
                               (uintptr_t) id);
    ZF_LOGF_IF(error, "Failed to set timeout");

    error = clientMux_unlock();
    ZF_LOGF_IF(error, "Failed to unlock time server");

    return OS_SUCCESS;
}

static OS_Error_t
_oneshot_absolute(
    TimeServer_Client* client,
    int                tid,
    uint64_t           ns)
{
    if (tid >= timers_per_client || tid < 0)
    {
        ZF_LOGE("invalid tid, 0 >= %d >= %d\n", tid, timers_per_client);
        return OS_ERROR_INVALID_PARAMETER;
    }

    int error = clientMux_lock();
    ZF_LOGF_IF(error, "Failed to lock time server");

    unsigned int token = getTimeToken(client, tid);

    error = tm_register_abs_cb(&timeManager, ns, token, signalClient,
                               (uintptr_t) token);
    if (error == ETIME)
    {
        signalClient(token);
        error = 0;
    }
    ZF_LOGF_IF(error, "Failed to set timeout");

    error = clientMux_unlock();
    ZF_LOGF_IF(error, "Failed to unlock time server");

    return OS_SUCCESS;
}

static OS_Error_t
_periodic(
    TimeServer_Client* client,
    int                tid,
    uint64_t           ns)
{
    if (tid >= timers_per_client || tid < 0)
    {
        ZF_LOGE("invalid tid, 0 >= %d >= %d\n", tid, timers_per_client);
        return OS_ERROR_INVALID_PARAMETER;
    }

    int error = clientMux_lock();
    ZF_LOGF_IF(error, "Failed to lock time server");

    unsigned int token = getTimeToken(client, tid);

    error = tm_register_periodic_cb(&timeManager, ns, 0, token, signalClient,
                                    (uintptr_t) token);
    ZF_LOGF_IF(error, "Failed to set timeout");

    error = clientMux_unlock();
    ZF_LOGF_IF(error, "Failed to unlock time server");

    return OS_SUCCESS;
}

static OS_Error_t
_stop(
    TimeServer_Client* client,
    int                tid)
{
    if (tid >= timers_per_client || tid < 0)
    {
        ZF_LOGE("invalid tid, 0 >= %d >= %d\n", tid, timers_per_client);
        return OS_ERROR_INVALID_PARAMETER;
    }

    int error = clientMux_lock();
    ZF_LOGF_IF(error, "Failed to lock time server");

    error = tm_deregister_cb(&timeManager, getTimeToken(client, tid));
    ZF_LOGF_IF(error, "Failed to deregister callback");

    error = clientMux_unlock();
    ZF_LOGF_IF(error, "Failed to unlock time server");

    return OS_SUCCESS;
}

static OS_Error_t
_completed(
    TimeServer_Client* client,
    uint32_t*          tmr)
{
    if (NULL == tmr)
    {
        return OS_ERROR_INVALID_PARAMETER;
    }

    int error = clientMux_lock();
    ZF_LOGF_IF(error, "Failed to lock time server");

    *tmr = client->timers;
    client->timers = 0;

    error = clientMux_unlock();
    ZF_LOGF_IF(error, "Failed to unlock time server");

    return OS_SUCCESS;
}

static OS_Error_t
_time(
    TimeServer_Client* client,
    uint64_t*          ns)
{
    *ns  = currentTimeNs();

    return OS_SUCCESS;
}

// Public Functions -----------------------------------------------------------

OS_Error_t
timeServer_rpc_oneshot_relative(
    int      id,
    uint64_t ns)
{
    TimeServer_Client* client;

    GET_CLIENT(client, timeServer_rpc_get_sender_id());

    return _oneshot_relative(client, id, ns);
}

OS_Error_t
timeServer_rpc_oneshot_absolute(
    int      id,
    uint64_t ns)
{
    TimeServer_Client* client;

    GET_CLIENT(client, timeServer_rpc_get_sender_id());

    return _oneshot_absolute(client, id, ns);
}

OS_Error_t
timeServer_rpc_periodic(
    int      id,
    uint64_t ns)
{
    TimeServer_Client* client;

    GET_CLIENT(client, timeServer_rpc_get_sender_id());

    return _periodic(client, id, ns);
}

OS_Error_t
timeServer_rpc_stop(
    int id)
{
    TimeServer_Client* client;

    GET_CLIENT(client, timeServer_rpc_get_sender_id());

    return _stop(client, id);
}

OS_Error_t
timeServer_rpc_completed(
    uint32_t* tmr)
{
    TimeServer_Client* client;

    GET_CLIENT(client, timeServer_rpc_get_sender_id());

    return _completed(client, tmr);
}

OS_Error_t
timeServer_rpc_time(
    uint64_t* ns)
{
    TimeServer_Client* client;

    GET_CLIENT(client, timeServer_rpc_get_sender_id());

    return _time(client, ns);
}

void
post_init(
    void)
{
    int error = clientMux_lock();
    ZF_LOGF_IF(error, "Failed to lock timer server");

    error = camkes_io_ops(&io_ops);
    ZF_LOGF_IF(error, "Failed to get camkes_io_ops");

    if (plat_pre_init)
    {
        plat_pre_init();
    }

    error = ltimer_default_init(&ltimer, io_ops, timerHandler, NULL);
    ZF_LOGF_IF(error, "Failed to init timer");

    if (plat_post_init)
    {
        plat_post_init(&ltimer);
    }

    int num_timers = timers_per_client * TIMESERVER_CLIENTS_MAX;
    tm_init(&timeManager, &ltimer, &io_ops, num_timers);
    for (unsigned int i = 0; i < num_timers; i++)
    {
        error = tm_alloc_id_at(&timeManager, i);
        ZF_LOGF_IF(error, "Failed to alloc id at %u\n", i);
    }

    error = clientMux_unlock();
    ZF_LOGF_IF(error, "Failed to unlock timer server");
}
